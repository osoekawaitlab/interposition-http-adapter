{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"interposition-http-adapter","text":"<p>HTTP adapter for Interposition. Serves recorded HTTP interactions from an Interposition <code>Cassette</code> as a real HTTP server, allowing you to replay captured API responses for testing and development.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install interposition-http-adapter\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p><code>InterpositionHttpAdapter</code> is an ASGI application (based on Starlette) that replays HTTP interactions through an Interposition <code>Broker</code>.</p> <pre><code>from interposition import (\n    Broker,\n    Cassette,\n    Interaction,\n    InteractionRequest,\n    ResponseChunk,\n)\nimport uvicorn\n\nfrom interposition_http_adapter import InterpositionHttpAdapter\n\n# 1. Build an InteractionRequest describing the HTTP request to match\nrequest = InteractionRequest(\n    protocol=\"http\",\n    action=\"GET\",\n    target=\"/api/data\",\n    headers=(),\n    body=b\"\",\n)\n\n# 2. Build ResponseChunks with status_code in the first chunk's metadata\nresponse_chunks = (\n    ResponseChunk(\n        data=b'{\"message\": \"hello\"}',\n        sequence=0,\n        metadata=((\"status_code\", \"200\"),),\n    ),\n)\n\n# 3. Create a Cassette containing the interaction\ninteraction = Interaction(\n    request=request,\n    fingerprint=request.fingerprint(),\n    response_chunks=response_chunks,\n)\ncassette = Cassette(interactions=(interaction,))\n\n# 4. Create a Broker in replay mode\nbroker = Broker(cassette=cassette, mode=\"replay\")\n\n# 5. Create the adapter and serve it\napp = InterpositionHttpAdapter(broker=broker)\nuvicorn.run(app, host=\"127.0.0.1\", port=8000)\n</code></pre> <p>Once the server is running, a <code>GET</code> request to <code>http://127.0.0.1:8000/api/data</code> returns the recorded response with status code 200 and body <code>{\"message\": \"hello\"}</code>. Requests that do not match any recorded interaction return a <code>500 Internal Server Error</code> response.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Detailed documentation is available in MkDocs: https://osoekawaitlab.github.io/interposition-http-adapter/.</p>"},{"location":"#cli","title":"CLI","text":"<p>The package provides a command-line interface:</p> <pre><code>interposition_http_adapter --version\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"adr/0000-adr-template/","title":"ADR 0000: This is ADR Template and Short Title of the Architectural Decision Goes Here","text":""},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-http-framework-selection/","title":"ADR 0001: Use Starlette and uvicorn as HTTP Framework","text":""},{"location":"adr/0001-http-framework-selection/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-http-framework-selection/#date","title":"Date","text":"<p>2026-02-10</p>"},{"location":"adr/0001-http-framework-selection/#context","title":"Context","text":"<p>The HTTP adapter needs a framework to serve HTTP and WebSocket requests as a standalone server. The requirements are:</p> <ol> <li>HTTP and WebSocket Support: The adapter intercepts both HTTP and WebSocket protocols</li> <li>Lightweight Dependencies: As a testing library, minimizing transitive dependencies is important</li> <li>Concurrent Request Handling: Record mode involves upstream I/O, and tests may run in parallel</li> </ol>"},{"location":"adr/0001-http-framework-selection/#decision","title":"Decision","text":"<p>Use Starlette as the ASGI framework and uvicorn as the ASGI server.</p> <p>The adapter class extends Starlette's application class, providing an ASGI-compatible application that can be served by uvicorn.</p>"},{"location":"adr/0001-http-framework-selection/#rationale","title":"Rationale","text":"<ul> <li>Unified Protocol Support: HTTP and WebSocket handled through a single ASGI interface, avoiding fragmented APIs</li> <li>Async-First Design: Non-blocking I/O handles concurrent requests naturally, critical for record mode (upstream forwarding) and parallel test execution</li> <li>Lightweight Footprint: Only 5 transitive packages (starlette, uvicorn, anyio, sniffio, h11)</li> <li>ASGI Standard: Well-established standard with broad ecosystem support and interoperability</li> </ul>"},{"location":"adr/0001-http-framework-selection/#implications","title":"Implications","text":""},{"location":"adr/0001-http-framework-selection/#positive","title":"Positive","text":"<ul> <li>Single framework covers both HTTP and WebSocket protocols</li> <li>Concurrent upstream forwarding in record mode without thread pool scaling</li> <li>Parallel test execution supported naturally via async event loop</li> </ul>"},{"location":"adr/0001-http-framework-selection/#concerns","title":"Concerns","text":"<ul> <li>Adds runtime dependencies (~5 transitive packages), which increases footprint for a testing library (mitigation: all packages are lightweight and widely adopted)</li> <li>Async programming model adds complexity compared to synchronous alternatives (mitigation: async complexity is contained within the adapter; users interact via standard HTTP)</li> </ul>"},{"location":"adr/0001-http-framework-selection/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-http-framework-selection/#stdlib-httpserver","title":"stdlib http.server","text":"<p>Using Python's built-in <code>http.server</code> module.</p> <ul> <li>Pros: Zero dependencies, simple API, proven reliability</li> <li>Cons: Synchronous (single-threaded by default), no WebSocket support, would require ThreadingMixIn for concurrency and a separate WebSocket library</li> <li>Reason for rejection: No WebSocket support and synchronous model would require significant workarounds for concurrent request handling</li> </ul>"},{"location":"adr/0001-http-framework-selection/#flask","title":"Flask","text":"<p>Using Flask as a WSGI framework.</p> <ul> <li>Pros: Simple API, widely known, large ecosystem</li> <li>Cons: Synchronous WSGI, no native WebSocket support, would need extensions for async and WebSocket</li> <li>Reason for rejection: Same limitations as stdlib regarding synchronous model and WebSocket support</li> </ul>"},{"location":"adr/0001-http-framework-selection/#aiohttp","title":"aiohttp","text":"<p>Using aiohttp as both HTTP client and server.</p> <ul> <li>Pros: Async, supports both HTTP and WebSocket, can serve as HTTP client for upstream forwarding</li> <li>Cons: Heavier dependency footprint (multidict, yarl, frozenlist, aiosignal), more opinionated API</li> <li>Reason for rejection: Heavier dependencies without proportional benefit; ASGI standard provides better interoperability</li> </ul>"},{"location":"adr/0001-http-framework-selection/#future-direction","title":"Future Direction","text":"<p>Revisit if dependency weight becomes a concern for users or if the ASGI ecosystem evolves significantly.</p>"},{"location":"adr/0001-http-framework-selection/#references","title":"References","text":"<ul> <li>Starlette Documentation</li> <li>ASGI Specification</li> <li>uvicorn Documentation</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/","title":"ADR 0002: HTTP to InteractionRequest Mapping Conventions","text":""},{"location":"adr/0002-http-interaction-mapping/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-http-interaction-mapping/#date","title":"Date","text":"<p>2026-02-11</p>"},{"location":"adr/0002-http-interaction-mapping/#context","title":"Context","text":"<p>The HTTP adapter translates between HTTP requests/responses and Interposition's protocol-agnostic data model (<code>InteractionRequest</code> and <code>ResponseChunk</code>). A consistent mapping convention is needed so that recorded interactions are correctly matched during replay.</p> <p>Interposition provides the following fields for request representation:</p> <ul> <li><code>protocol</code>: Protocol identifier</li> <li><code>action</code>: Action or method name</li> <li><code>target</code>: Target resource</li> <li><code>headers</code>: Key-value pairs</li> <li><code>body</code>: Raw bytes</li> </ul> <p>For responses, <code>ResponseChunk</code> provides:</p> <ul> <li><code>data</code>: Chunk payload</li> <li><code>sequence</code>: Chunk ordering</li> <li><code>metadata</code>: Key-value pairs for protocol-specific information</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#decision","title":"Decision","text":""},{"location":"adr/0002-http-interaction-mapping/#request-mapping","title":"Request Mapping","text":"<p>Map HTTP requests to <code>InteractionRequest</code> as follows:</p> <ul> <li><code>protocol</code> = <code>\"http\"</code></li> <li><code>action</code> = HTTP method (e.g., <code>\"GET\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>, <code>\"DELETE\"</code>)</li> <li><code>target</code> = Request path with query string when present (e.g., <code>\"/api/data?kind=user\"</code>)</li> <li><code>headers</code> = HTTP request headers as tuple of key-value pairs</li> <li><code>body</code> = Request body bytes</li> </ul> <p>Matching policy for which headers participate in fingerprinting is intentionally adapter-specific and may be derived from recorded interaction schemas rather than fixed global allow/deny lists.</p>"},{"location":"adr/0002-http-interaction-mapping/#response-mapping","title":"Response Mapping","text":"<p>Encode HTTP response information across <code>ResponseChunk</code> instances:</p> <ul> <li>First chunk (sequence=0): <code>metadata</code> contains status code as <code>(\"status_code\", \"&lt;code&gt;\")</code> (e.g., <code>(\"status_code\", \"200\")</code>). Response headers are reserved for future definition.</li> <li>All chunks: <code>data</code> contains a segment of the response body.</li> </ul> <p>This mirrors HTTP's own structure where status code and headers are sent once at the beginning, followed by body data which may arrive in multiple chunks.</p>"},{"location":"adr/0002-http-interaction-mapping/#rationale","title":"Rationale","text":"<ul> <li>Direct Mapping: HTTP concepts map naturally to Interposition's fields without lossy transformations</li> <li>Replay Correctness for Query-driven APIs: Including query string in <code>target</code> avoids collisions between requests that share a path but differ by query</li> <li>User-defined Header Participation: Reusing recorded header keys lets cassette authors control which headers influence matching, instead of imposing adapter-side allow/deny lists</li> <li>Metadata for Response Attributes: Status code and response headers are protocol-specific and don't have dedicated fields in <code>ResponseChunk</code>, so metadata is the appropriate storage</li> <li>First-Chunk Convention: Placing status code only in the first chunk matches HTTP semantics where status and headers precede the body</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#implications","title":"Implications","text":""},{"location":"adr/0002-http-interaction-mapping/#positive","title":"Positive","text":"<ul> <li>Consistent fingerprinting enables reliable request matching across environments</li> <li>Clear separation between request matching fields and response metadata</li> <li>Query string-sensitive APIs can be replayed without extra adapter configuration</li> <li>Header matching policy can be chosen per adapter/use case while keeping a consistent data model</li> <li>Chunked responses are represented naturally</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#concerns","title":"Concerns","text":"<ul> <li>If recorded interactions include volatile headers, replay may fail unless those values are reproduced by clients (mitigation: curate recorded headers at capture time)</li> <li>Status code stored as string in metadata requires parsing (mitigation: simple <code>int()</code> conversion, validated at recording time)</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-http-interaction-mapping/#full-url-as-target","title":"Full URL as Target","text":"<p>Using the complete URL (including scheme, host, port) as the <code>target</code> field.</p> <ul> <li>Pros: Preserves full request context</li> <li>Cons: Fingerprints would differ between environments (localhost:8080 vs production host), breaking replay portability</li> <li>Reason for rejection: Environment-dependent fingerprints would make cassettes non-portable</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#dedicated-response-model","title":"Dedicated Response Model","text":"<p>Creating a custom response model instead of using <code>ResponseChunk.metadata</code>.</p> <ul> <li>Pros: Type-safe, explicit fields for status code and headers</li> <li>Cons: Breaks compatibility with Interposition's data model, requires custom serialization</li> <li>Reason for rejection: Working within Interposition's existing model is simpler and maintains compatibility</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#status-code-in-every-chunk","title":"Status Code in Every Chunk","text":"<p>Storing the status code in every <code>ResponseChunk</code>'s metadata for redundancy.</p> <ul> <li>Pros: Any chunk can be interpreted independently</li> <li>Cons: Redundant data, diverges from HTTP semantics, risk of inconsistency between chunks</li> <li>Reason for rejection: HTTP sends status code once; the mapping should reflect this</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#future-direction","title":"Future Direction","text":"<ul> <li>Define response header encoding convention when response header matching is needed</li> <li>Standardize optional canonicalization and filtering profiles for headers and bodies (for example, stable JSON serialization and removal of volatile fields) for common use cases</li> </ul>"},{"location":"adr/0002-http-interaction-mapping/#references","title":"References","text":"<ul> <li>Interposition data model documentation</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/","title":"ADR 0003: Replay Miss HTTP Status Policy","text":""},{"location":"adr/0003-replay-miss-http-status-policy/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-replay-miss-http-status-policy/#date","title":"Date","text":"<p>2026-02-11</p>"},{"location":"adr/0003-replay-miss-http-status-policy/#context","title":"Context","text":"<p>In replay mode, the HTTP adapter may receive requests that do not match any interaction in the cassette. The adapter must map this replay miss to an HTTP response status.</p> <p>If miss handling is ambiguous, tests can become hard to diagnose because it is unclear whether a response came from a valid recorded interaction or from fallback behavior.</p>"},{"location":"adr/0003-replay-miss-http-status-policy/#decision","title":"Decision","text":"<p>When no interaction matches during replay, the adapter returns HTTP <code>500 Internal Server Error</code>.</p>"},{"location":"adr/0003-replay-miss-http-status-policy/#rationale","title":"Rationale","text":"<ul> <li>Fail-fast for test environments: A replay miss usually indicates a recording gap or request-mapping mismatch, both of which should fail loudly.</li> <li>Clearer diagnosis than <code>404</code>: <code>404</code> can be confused with a legitimate recorded upstream response, while <code>500</code> signals adapter-level failure to satisfy replay.</li> <li>Simple and deterministic behavior: A single default policy avoids hidden fallback semantics during early development.</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#implications","title":"Implications","text":""},{"location":"adr/0003-replay-miss-http-status-policy/#positive-implications","title":"Positive Implications","text":"<ul> <li>Missing or stale cassettes are detected immediately.</li> <li>CI failures point directly to replay configuration or recording completeness issues.</li> <li>Consumers can distinguish replay-system failures from domain-level <code>404</code> responses.</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#concerns","title":"Concerns","text":"<ul> <li>Some consumers may expect miss behavior to mirror upstream <code>404</code> semantics (mitigation: document replay miss semantics clearly and provide assertion helpers in test code that treat <code>500</code> as cassette coverage failure)</li> <li><code>500</code> may be too strict for exploratory or non-test usage (mitigation: keep current default for CI/test safety and revisit a configurable miss policy when non-test use cases become concrete)</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-replay-miss-http-status-policy/#return-404-not-found","title":"Return <code>404 Not Found</code>","text":"<ul> <li>Pros: Familiar REST-style response for missing resources.</li> <li>Cons: Blurs distinction between real recorded <code>404</code> and replay miss; can hide cassette gaps.</li> <li>Reason for rejection: Lower diagnostic value for replay correctness.</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#return-501-not-implemented","title":"Return <code>501 Not Implemented</code>","text":"<ul> <li>Pros: Explicitly indicates unsupported behavior.</li> <li>Cons: Semantically intended for unimplemented server capabilities (for example, unsupported HTTP method), not missing replay data.</li> <li>Reason for rejection: Misleading status semantics.</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#configurable-policy-500-404-custom","title":"Configurable Policy (<code>500</code> / <code>404</code> / custom)","text":"<ul> <li>Pros: Flexible across environments and use cases.</li> <li>Cons: More complexity and risk of inconsistent behavior across projects.</li> <li>Reason for rejection: Deferred until concrete multi-mode requirements emerge.</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#future-direction","title":"Future Direction","text":"<ul> <li>Revisit policy configurability if production-oriented replay workflows require softer miss handling.</li> <li>If configurability is introduced, define a safe default that preserves fail-fast behavior in test/CI contexts.</li> </ul>"},{"location":"adr/0003-replay-miss-http-status-policy/#references","title":"References","text":"<ul> <li>HTTP Semantics (RFC 9110)</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of architectural decisions made for the interposition-http-adapter project.</p>"},{"location":"architecture/overview/#architecture-decision-records","title":"Architecture Decision Records","text":""},{"location":"architecture/overview/#adr-0001-use-starlette-and-uvicorn-as-http-framework","title":"ADR-0001: Use Starlette and uvicorn as HTTP Framework","text":"<p>Status: Accepted | Date: 2026-02-10</p> <p>Use Starlette as the ASGI framework and uvicorn as the ASGI server for unified HTTP and WebSocket support with lightweight dependencies.</p>"},{"location":"architecture/overview/#adr-0002-http-to-interactionrequest-mapping-conventions","title":"ADR-0002: HTTP to InteractionRequest Mapping Conventions","text":"<p>Status: Accepted | Date: 2026-02-11</p> <p>Define conventions for mapping HTTP requests to InteractionRequest and ResponseChunk to HTTP responses, with status code in the first chunk's metadata.</p>"},{"location":"architecture/overview/#adr-0003-replay-miss-http-status-policy","title":"ADR-0003: Replay Miss HTTP Status Policy","text":"<p>Status: Accepted | Date: 2026-02-11</p> <p>Define the adapter response policy for cassette replay misses as HTTP 500 to keep replay failures explicit.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#interpositionhttpadapter","title":"<code>InterpositionHttpAdapter</code>","text":""},{"location":"reference/#interposition_http_adapter.app.InterpositionHttpAdapter","title":"interposition_http_adapter.app.InterpositionHttpAdapter","text":"<p>               Bases: <code>Starlette</code></p> <p>ASGI application that replays HTTP interactions via an Interposition Broker.</p> Source code in <code>src/interposition_http_adapter/app.py</code> <pre><code>class InterpositionHttpAdapter(Starlette):\n    \"\"\"ASGI application that replays HTTP interactions via an Interposition Broker.\"\"\"\n\n    def __init__(self, broker: Broker) -&gt; None:\n        \"\"\"Initialize the adapter with a Broker.\n\n        Args:\n            broker: The Interposition Broker to use for replaying interactions.\n        \"\"\"\n        self._broker = broker\n        routes = [\n            Route(\"/{path:path}\", _create_get_handler(broker), methods=[\"GET\"]),\n        ]\n        super().__init__(routes=routes)\n</code></pre>"},{"location":"reference/#interposition_http_adapter.app.InterpositionHttpAdapter.__init__","title":"__init__","text":"<pre><code>__init__(broker: Broker) -&gt; None\n</code></pre> <p>Initialize the adapter with a Broker.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>Broker</code> <p>The Interposition Broker to use for replaying interactions.</p> required Source code in <code>src/interposition_http_adapter/app.py</code> <pre><code>def __init__(self, broker: Broker) -&gt; None:\n    \"\"\"Initialize the adapter with a Broker.\n\n    Args:\n        broker: The Interposition Broker to use for replaying interactions.\n    \"\"\"\n    self._broker = broker\n    routes = [\n        Route(\"/{path:path}\", _create_get_handler(broker), methods=[\"GET\"]),\n    ]\n    super().__init__(routes=routes)\n</code></pre>"},{"location":"specifications/","title":"E2E Specs","text":"<p>Gauge spec files are embedded below so the executable acceptance criteria are visible in the docs.</p>"},{"location":"specifications/#http-replay-server","title":"HTTP Replay Server","text":"<p>This specification verifies that the HTTP replay server returns recorded responses from a Cassette.</p>"},{"location":"specifications/#returns-recorded-response-for-a-matching-get-request","title":"Returns recorded response for a matching GET request","text":"<ul> <li>Create a GET cassette for \"/api/data\" with status \"200\" and body \"hello\"</li> <li>Create a replay broker with the cassette</li> <li>Create an HTTP adapter with the broker</li> <li>Start the adapter on port \"19876\"</li> <li>Send a GET request to \"http://localhost:19876/api/data\"</li> <li>Verify that the response status code is \"200\"</li> <li>Verify that the response body is \"hello\"</li> </ul>"},{"location":"specifications/#returns-500-for-a-request-not-in-the-cassette","title":"Returns 500 for a request not in the Cassette","text":"<ul> <li>Create a GET cassette for \"/api/data\" with status \"200\" and body \"hello\"</li> <li>Create a replay broker with the cassette</li> <li>Create an HTTP adapter with the broker</li> <li>Start the adapter on port \"19876\"</li> <li>Send a GET request to \"http://localhost:19876/api/unknown\"</li> <li>Verify that the response status code is \"500\"</li> </ul>"},{"location":"specifications/#matches-query-string-as-part-of-request-target","title":"Matches query string as part of request target","text":"<ul> <li>Create a GET cassette for \"/api/data?kind=user\" with status \"200\" and body \"hello-query\"</li> <li>Create a replay broker with the cassette</li> <li>Create an HTTP adapter with the broker</li> <li>Start the adapter on port \"19876\"</li> <li>Send a GET request to \"http://localhost:19876/api/data?kind=user\"</li> <li>Verify that the response status code is \"200\"</li> <li>Verify that the response body is \"hello-query\"</li> </ul> <ul> <li>Stop the adapter if running</li> </ul>"},{"location":"specifications/#interposition_http_adapter-package-metadata-verification","title":"interposition_http_adapter Package Metadata Verification","text":"<p>This specification ensures that the <code>interposition_http_adapter</code> package is properly configured and follows industry standards for versioning.</p>"},{"location":"specifications/#ensure-version-follows-semantic-versioning","title":"Ensure version follows Semantic Versioning","text":"<ul> <li>Import the \"interposition_http_adapter\" package</li> <li>Verify that \"version\" follows the Semantic Versioning format</li> </ul>"},{"location":"specifications/#verify-cli-version-command","title":"Verify CLI version command","text":"<ul> <li>Execute the CLI command with \"--version\"</li> <li>Import the \"interposition_http_adapter\" package</li> <li>Verify that the output matches the version from the package</li> </ul>"}]}